var Discord = require("discord.js");
var config = require("./config.json");
var sqlite = require("sqlite");

var client = new Discord.Client();

function deleteMessage(message) {
    message.delete()
        .then(message => console.log(`${message.author.username}: ${message.content.slice(1, 10)}... Deleted`))
        .catch(console.error);
}

function ennumerate(array){
    array.sort();
    var finalString = '';
    array.forEach( (value, index) => {
        finalString += `${index+1}. ${value}`;
        if (!value.includes("\n")) finalString += "\n";
    });
    return finalString;
}

async function send(channel, message){
    var update = await channel.send("**__UPDATED LIST BELOW__**");
    var sent = await channel.send(message);
    sent.pin();
}

client.on("ready", function () {
    console.log(`Logged in as ${client.user.tag}!`);
});

client.on("message", async (msg) => {
    
    // Fetch received message contents
    var mContent = msg.content; 
    // Determine the command category to process
    var command = msg.content.split(" ")[0];
    // List time in context with the command 
    var task = mContent.split(`${command} `)[1];
    // Channel name
    var mChannel = msg.channel;
    console.log(`\nChannel: ${mChannel.name}`);
    
    // In case of any system message generated by the bot, delete it.
    // Eg. "Stuff-bot pinned a message" will show up as empty message in the logs
    // Delete this message to keep the channel clean
    if (mContent.startsWith('.') || mContent == '') await deleteMessage(msg);

    if (command == ".add") {
        // Fetch the last pinned message and add the new task to the list
        var messages = await mChannel.messages.fetchPinned();
        var pinnedContent = [];
        // Seperate ennumerated items from indices and add the item to the list
        messages.forEach((message) => {
            pinnedContent.push(...message.content.split(/[\d]+. /).slice(1), task);
            message.unpin();
        });
        // Ennumerate the new list and sent it back
        send(mChannel, ennumerate(pinnedContent));

    }

    // Delete any unpinned messages in the channel
    else if (command == ".clear") {
        var messages = await mChannel.messages.fetch();
        messages.forEach((message) => {
            if (!message.pinned) deleteMessage(message);
        });
    }
    
    // Remove any item from the list
    // Command supplied with the item index in the list or the item itself
    else if (command == ".remove") {
        // Fetch the last pinned message and add the new task to the list
        var messages = await mChannel.messages.fetchPinned();
        var pinnedContent = [];
        messages.forEach((message) => {
            pinnedContent = message.content.split(/[\d]+. /).slice(1);
            message.unpin();
            var regex = /^\d/;
            // If the supplied parameter is an index
            if (regex.test(task)) pinnedContent.splice(parseInt(task)-1, 1);
            // If the supplied parameter is item itself
            else {
                var ind = pinnedContent.indexOf(task);
                pinnedContent.splice(ind, 1);
            }
        });
        send(mChannel, ennumerate(pinnedContent));
    }

    // Improve user interaction quality
    // The user need not add items one at at time
    // Add a list directly and it'll be ennumerated and pinned
    else if (command == ".enn") {
        var finalString = "";
        var messages = await mChannel.messages.fetchPinned();
        messages.forEach( (message) => {
            message.unpin();
            if (message.content.startsWith("1")) finalString = ennumerate(message.content.split(/[\d]+. /).slice(1));
            else finalString = ennumerate(message.content.split("\n"));
        })
        send(mChannel, finalString);
    }
    
    // Pin sent messages to use the channel as a notebook
    else if (mChannel.name == 'notes' && command==".note"){
        var sent = await mChannel.send(`${task}\n▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀`)
        sent.pin()
        
    }
});

client.login(config.BOT_TOKEN);
